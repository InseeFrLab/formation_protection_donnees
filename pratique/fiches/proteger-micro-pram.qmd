---
title: Appliquer PRAM
---

```{r}
library(dplyr)
library(sdcMicro)
```


# Les données

```{r}
source("../R/fun_import_data.R")
lfs_2023 <- import_lfs()
```

Nous allons étudier un extrait des données de l'Enquête emploi en continu de l'Insee.

```{r}
str(lfs_2023)
```

On y trouve les variables suivantes :

- **DEP** : département de résidence
- **SEXE** : sexe (1 = homme, 2 = femme)
- **AGE** : âge de l'individu
- **AGE6** : âge en 5 tranches (15 = 15-25, 25 = 25-49, 50 = 50-64, 65 = 65-89, 90 = 90 ans ou plus)
- **ACTEU** : statut d'activité (1 = emploi, 2 = chômage, 3 = inactivité)
- **DIP7** : diplôme le plus élevé obtenu (1 = bac+5 ou plus, 2 = bac +3/4, 3 = bac+2, 4 = bac, 5 = CAP, 6 = brevet, 7 = aucun diplôme, 9 = non réponse)
- **PCS1Q** : emploi principal (10 = agriculteurs, 20 = artisans, 30 = cadres, 40 = professions intermédiaires, 51 = employés qualifiés, 52 = employés peu qualifiés, 61 = ouvriers qualifiés, 62 = ouvriers peu qualifiés, 00 = non codé, 99 = non réponse)
- **ANCCHOM** : ancienneté au chômage
- **HHID** : identifiant du cluster
- **POIDS** : poids de sondage

# Définir son objet sdc

Le package `sdcMicro` a un fonctionnement spécial pusiqu'il utilise des **classes** (objets de type S4). En effet, il faut créer un objet qui regroupe toutes les informations concernant les données sur lequelles on veut appliquer une méthode de protection. Cet objet relève de la classe `sdcMicroObj`, on le crée en appelant la fonction `createSdcObj()` voici certains de ces arguments :

- `dat` : un jeu de micrdonnées ;
- `keyVars` : vecteur de noms (ou indices) de variables quasi-identifiantes catégorielles ;
- `numVars` : vecteur de noms (ou indices) de variables quasi-identifiantes continues ;
- `pramVars` : vecteur de noms (ou indices) de variables catégorielles à protéger via PRAM ;
- `weightVar` : nom (ou indice) du vecteur des poids de sondage ;
- `hhID` : nom (ou indice) de l'identifiant du cluster (s'il existe) ;
- `sensibleVar` : vecteur de noms (ou indices) des variables sensbiles (pour la l-diversité) ;
- `seed` : graine utilisée pour la reproductibilité des résultats

On peut créer un objet `sdcMicroObj` à partir des données de l'enquête emploi.

```{r}
key_vars1 <- c("DEP", "SEXE", "AGE6", "DIP7") # quasi-identifiants

sdc_object1 <- createSdcObj(
  dat=lfs_2023,
  keyVars=key_vars1,
  hhId = "HHID",
  # weightVar = "POIDS",
  sensibleVar = "ANCCHOM",
  pramVars = "ACTEU",
  seed = 20061789
)
```

L'objet contient **22 composants** ou **slots**, dont :
- `origData` : contient les données initiales, le vecteur de quasi-identifiants catégoriels (`keyVars`) et le vecteur des variables à protéger via PRAM (`pramVars`)
- `originalRisk` : les mesures de risques pour les données initiales (non modifiées) ;
- `risk` : les mesures de risques pour les données sur lesquelles on a appliquer une méthode de protection (modifiées) ;
- `utility` : les informations sur l'utilité des données ;
- `pram` : informations sur les variables pour lesquelles on a utilisé la méthode PRAM.

# Mesurer le risque

## k-anonymat

Par défaut les mesures de k-anonymat pour k = 2, k = 3 et k = 5 sont fournies.

```{r}
print(sdc_object1)
```

```{r}
sdc_object1@originalRisk$global$risk
```


```{r}
sdc_object1@originalRisk$global$risk_ER
```


```{r}
sdc_object1@originalRisk$global$risk_pct
```

```{r}
sdc_object1@originalRisk$global$max_risk
```

```{r}
sdc_object1@originalRisk$global$hier_risk_ER
```

```{r}
sdc_object1@originalRisk$global$hier_risk
```

```{r}
sdc_object1@originalRisk$global$hier_risk_pct
```

```{r}
risque_ind_original <- sdc_object1@originalRisk$individual

head(risque_ind_original)
```

La colonne `fk` donne, pour chaque combinaison unique de DEP, SEXE, AGE6 et DIP7, le nombre d'individus dans l'échantillon. Et `Fk` 

## Risque global

!!!! je ne suis pas sûre de l'utilisation de `risk` car dans la doc plutôt le risque après protection.

```{r}
print(sdc_object1, 'risk')
```

```{r}
lfs_indiv_at_risk <- sdc_object1@risk$individual %>%
  as_tibble() # plutôt sdc_object1@originalRisk$individual ?

lfs_indiv_at_risk %>%
  count(fk) %>% 
  mutate(part = n/sum(n)*100) %>%
  mutate(n_cum = cumsum(n), part_cum = cumsum(part))
```

L'échantillon est 1-anonyme ??????

# Appliquer PRAM

La méthode de protection des données PRAM est une **méthode perturbatrice** appliquée sur les microdonnées. Elle permet d'**intervertir les modalités d'une variable catégorielle sensible** pour certains individus afin qu'un attaquant ne puisse pas savoir s'il s'agit du veritable effectif ou non.

## PRAM général

### 1. Définir la matrice de transition

La matrice de transition présente la **probabilité qu'une modalité soit changée en une autre** pour tous les changements possibles.

```{r}
mat <- matrix(
  c(0.7,0.2,0.1,
    0.3, 0.6, 0.1,
    0.1, 0.1, 0.8
  ),
  nrow = 3,
  byrow = TRUE
)
row.names(mat) <- colnames(mat) <- levels(lfs_2023$ACTEU)

print(mat)
```

Dans cet exemple, la probabilité qu'un 1 reste un 1 est de 70%, alors que la probabilité qu'un 1 devienne un 2 est de 20%.

### 2. Appliquer un pram général

On appelle la fonction `pram()` et on précise la matrice de transition avec le paramètre `pd`.

```{r}
set.seed(12345) # graine pour la reproductibilité des résultats

pram_1 <- pram(
  lfs_2023, # données
  variables = "ACTEU", # variable sensible
  pd = mat, # matrice de transition
  alpha = NA
)

summary(pram_1)
```

Le `summary()` renvoit les informations principales sur les modifications des microdonnées. On voit la réalisation des échanges de modalités en comprant les fréquences avant et après perturbation.

### 3. Analyser les changements

Une fois qu'on a le jeu de données perturbé, il est nécessaire de comparer les résultats avant et après la perturbation. Cet aspect d'analyse de la perte d'utilité sera développé dans le paragraphe [dédié](#utilite).

```{r}
data_pram_1 <- do.call(cbind, pram_1) %>% data.frame()

data_pram_1 %>% 
  count(ACTEU, ACTEU_pram) %>% 
  group_by(ACTEU) %>% 
  mutate(part = n/sum(n)*100) %>% 
  select(-n) %>% 
  tidyr::pivot_wider(
    names_from = ACTEU_pram, values_from = part, names_prefix = "PRAM_"
  )
```

```{r}
# ATTENTION ce type de PRAM n'est pas invariant: les estimatons sont biaisées
# Calcul du taux de chômage
data_pram_1 %>% 
  summarise(
    taux_chomage = sum(ACTEU == 2)/sum(ACTEU %in% 1:2) *100,
    taux_chomage_pram = sum(ACTEU_pram == 2)/sum(ACTEU_pram %in% 1:2) *100
  )
```

La perturbation injectée par l'utilisation de pram modifie grandement le taux de chômage: 7 dans les données originales, et 30 dans les données protégées. Les estimations sont biaisées. Une variante de pram permet d'obtenir des estimateurs non-biaisés : le **pram invariant**.


```{r}
# Récupérer les données
data_pram_1 <- do.call(cbind, pram_1) %>% data.frame()

# invariance globale
data_pram_1 %>% 
  summarise(mean(ACTEU == ACTEU_pram))
```

Dans 75% des cas (i.e. des lignes du fichier), le statut d'activité dans le fichier original est le même que celui dans le fichier modifié avec pram.

## PRAM invariant

```{r}
set.seed(12345)

pram_2 <- pram(
  lfs_2023,
  variables = "ACTEU",
  pd = 0.8 # valeur minimale des probabilités sur la diagonale, valeur par défaut
)
str(pram_2) #liste
```

On peut voir la matrice de transition qui a été générée à partir de `pd = 0.8`.

```{r}
attributes(pram_2)$pram_params$ACTEU$Rs
```

Chaque élément de la diagonale vaut au moins 0.8, les autres probabilités sont distribuées de manière uniforme. Toutes les lignes somment à 1.


```{r}
# Récupérer les données
data_pram_2 <- do.call(cbind, pram_2) %>% data.frame()

# invariance globale
data_pram_2 %>% 
  summarise(mean(ACTEU == ACTEU_pram))
```

Dans 96% des cas, le statut d'activité dans le fichier original est le même que celui dans le fichier modifié avec pram.

Le taux de chômage dans l'échantillon est-il biaisé ?

```{r}
data_pram_2 %>% 
  summarise(
    taux_chomage = sum(ACTEU == 2)/sum(ACTEU %in% 1:2) *100,
    taux_chomage_pram = sum(ACTEU_pram == 2)/sum(ACTEU_pram %in% 1:2) *100
  )
```

Le taux de chômage dans les données originales est de 7.4%¨et il est de 7.5% dans les données modifiées par pram. L'utilisation d'un **pram invariant** permet de conserver des marges proches de celles originales sur la variable modifiée.

```{r}
# Comparaison
data_pram_1 %>% 
  count(ACTEU, ACTEU_pram) %>% 
  group_by(ACTEU) %>% 
  mutate(part = n/sum(n)*100) %>% 
  select(-n) %>% 
  tidyr::pivot_wider(
    names_from = ACTEU_pram, values_from = part, names_prefix = "PRAM_"
  )

# Le taux de chômage dans l'échantillon est-il biaisé ?
```


```{r}
attributes(pram_2) #résumé
```


## Seconde tentative --------

```{r}

pram_2 <- pram(
  lfs_2023,
  variables = "ACTEU",
  strata_variables = "AGE6",
  pd = 0.8
)

attributes(pram_2) #résumé 

# Récupérer les données
data_pram_2 <- do.call(cbind, pram_2) %>% data.frame()

# invariance globale
data_pram_2 %>% 
  summarise(mean(ACTEU == ACTEU_pram))

# Comparaison matrice de transition et observations
attributes(pram_2)$pram_params$ACTEU$Rs

data_pram_2 %>% 
  count(ACTEU, ACTEU_pram) %>% 
  group_by(ACTEU) %>% 
  mutate(part = n/sum(n)*100) %>% 
  select(-n) %>% 
  tidyr::pivot_wider(
    names_from = ACTEU_pram, values_from = part, names_prefix = "PRAM_"
  )

data_pram_2 %>% 
  summarise(
    tc = sum(ACTEU == 2)/sum(ACTEU %in% 1:2) *100,
    tc_pram = sum(ACTEU_pram == 2)/sum(ACTEU_pram %in% 1:2) *100
  )

```


## PRAM Invariant  -----

Pour le PRAM invariant on 

```{r}

# Par défaut, la fonction pram() calcule un pram dit invariant 
# pour empêcher les 

pram_4 <- pram(
  lfs_2023,
  variables = "ACTEU",
  #pd = 0.5,
  alpha = 0.8
)

attributes(pram_4)$pram_params$ACTEU$Rs

data_pram_4 <- do.call(cbind, pram_4) %>% data.frame()

data_pram_4 %>% 
  count(ACTEU, ACTEU_pram) %>% 
  group_by(ACTEU) %>% 
  mutate(part = n/sum(n)*100) %>% 
  select(-n) %>% 
  tidyr::pivot_wider(
    names_from = ACTEU_pram, values_from = part, names_prefix = "PRAM_"
  )

# Calcul du taux de chômage
data_pram_4 %>% 
  summarise(
    tc = sum(ACTEU == 2)/sum(ACTEU %in% 1:2) *100,
    tc_pram = sum(ACTEU_pram == 2)/sum(ACTEU_pram %in% 1:2) *100
  )
```

## Application sur notre objet sdcMicro -------
```{r}
pram_sdc  <- pram(sdc_object1, variables = NULL, strata_variables = NULL)
str(pram_sdc,1)

pram_sdc@origData %>%
  group_by(ACTEU) %>%
  count()

pram_sdc@manipPramVars %>%
  group_by(ACTEU) %>%
  count()

# Comparaison:
prop.table(
  table(
    pram_sdc@manipPramVars$ACTEU,
    pram_sdc@origData$ACTEU
  ), margin = 1
)

#  Les paramètres utilisés par défaut:
sdc_object1@pram
pram_sdc@pram

# La matrice de transition
pram_sdc@pram$params$ACTEU$Rs

# Transitions
pram_sdc@pram$transitions$ACTEU

```


# Utilité {#utilite}

