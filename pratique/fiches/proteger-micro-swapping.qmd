---
title: Appliquer le Target Record Swapping
href: pratique/fiches/proteger-micro-swapping.html
code-block-bg: true
code-block-border-left: "#bf9aff"
code-fold: show
---


# Objectif:

La fiche pratique présente comment appliquer le `Target Record Swapping` à
un jeu de données individuelles afin d'assurer une protection optimale 
des informations confidentielles des individus (ou ménages ou entreprises) qui 
le composent.

La première partie s'attache à présenter les différentes étapes à suivre pour 
que cette application soit pertinente au regard des données utilisées.

La seconde partie montre comment utiliser la fonction `sdcMicro::recordSwap()` 
pour appliquer la méthode à un jeu de données dont on aura repérer les 
individus à risque préalablement.


# Rappels sur la méthode:

Le `Target Record Swapping (TRS)` est une méthode s'appliquant directement sur un jeu 
de données individuelles pour réduire principalement les risques de ré-identification.
Il ciblera donc les individus pour lesquels ce risque est jugé trop élevé, c'est-à-dire  
ceux partageant des caractéristiques trop rares sur un ensemble 
de variables dites quasi-identifiantes. Les variables quasi-identifiantes sont celles 
qui sont susceptibles d'être déjà publiques ou du moins à la disposition d'un attaquant.

D'où son nom: le *swapping*, c'est-à-dire 
l'échange, va concerner des unités de la base (les *records*) détectés à l'avance, 
devenant ainsi les cibles (*target*) sur lesquelles on va se concentrer.

Bien qu'elle soit appliquée sur des microdonnées, la méthode peut être utilisée pour 
la diffusion de données tabulées. Dans ce cas, en tant que méthode pré-tabulée, 
elle permet de produire des tableaux parfaitement additifs.


En quoi consiste la méthode ?

Après avoir détecté un individu dont le risque de ré-identification est jugé trop 
élevé, un autre individu est tiré aléatoirement parmi les individus au risque de ré-identification 
les plus faibles et certaines des caractéristiques de ces deux individus sont échangées (*swapped*).

Après l'échange, la ré-identification de l'individu est rendue beaucoup plus difficile et 
ne permet plus d'obtenir d'informations pertinentes à son sujet.

Imaginons un exemple très simple. Sur un territoire donné découpé en six zones 
où résident un certain nombre d'individus. Avec les informations disponibles à leur
sujet, on considère qu'un seul individu a un risque de ré-identification trop élevé 
(croix rouge sur la @fig-swap-avant).


::: {#fig-swap-avant}

![Avant swapping](images/swapping-exemple-avant.png)

:::


On tire alors au hasard un autre individu présent sur le territoire pour échanger 
certaines de leurs caractéristiques. Ce tirage pourrait être purement aléatoire. Mais, cela 
conduirait à détruire certaines statistiques bien utiles. Par exemple, en trouvant 
un individu d'une autre zone partageant certaines caractéristiques (par exemple 
le sexe, l'âge et la catégorie sociale, @fig-swap-apres), on s'assure de conserver les marges 
sur ces variables au niveau géographique le plus fin. 

En revanche, les autres caractéristiques sont bruitées de façon non contrôlée.

::: {#fig-swap-apres}

![Après swapping](images/swapping-exemple-après.png)
:::

Ainsi, l'éventuelle ré-identification de l'individu à risque ne pourrait conduire 
l'attaquant qu'à obtenir des informations très probablement fausses à son sujet.

## Les variables de similarité

La méthode est très souple puisqu'elle permet de s'adapter aux données dont on dispose et 
aux besoins en termes de diffusion. Les **variables de similarité** entre individus échangés 
peuvent ainsi être choisies parmi les variables dont on veut conserver 
le mieux possible l'information marginale. En effet, en échangeant des individus 
parfaitement similaires sur certaines caractéristiques (**les variables de similarité**), 
l'échange ne produira aucune perte d'information sur celles-ci. 

::: {.callout-warning}
### Similaraité et ré-identification

Si l'objectif est de réduire le risque de ré-identification, il n'est pas conseillé 
de considérer toutes les variables quasi-identifiantes comme variables de similarité.

:::



::: {.callout-tip}
### Utiliser la hiérarchie des emboîtements géographiques

Les données contiennent généralement des informations géographiques. Or, la géographie, 
en particulier à des niveaux fins, est très identifiante. On choisira en général 
d'échanger des individus résidant à des endroits différents, en tenant compte 
du niveau géographique auquel un individu est facilement ré-identifiable.

Par exemple, si un individu est facilement ré-identifiable dans sa commune mais 
pas dans son département de résidence, alors on privilégiera l'échange avec 
un autre individu du département en dehors de la commune de notre individu à risque.
Si le niveau départemental posait lui aussi problème on remonterait au niveau régional, etc.


:::



::: {.callout-tip}
### Une astuce pour gérer la présence de poids de sondage

Si nous disposons d'un échantillon, chaque individu dispose d'un poids de sondage. 
Avec le `Target Record Swapping`, on prend le risque d'échanger deux individus avec des poids très différents et 
de déséquilibrer des agrégats importants. Pour éviter ce genre de désagrément, il est possible
d'ajouter le poids parmi les variables de similarité, sous la forme d'un arrondi à l'unité 
ou bien de tranches de valeurs. On pourra également exclure des donneurs potentiels, 
les individus ayant des poids très élevés comparés aux autres. Ceci permettra de limiter 
les déformations des distributions.

:::


### Comment définir des individus similaires ?

La **similarité** entre deux individus peut être envisagée de deux manières:

- en cherchant la **correspondance exacte** sur les variables de similarité, quitte à relâcher 
des contraintes quand il n'y pas de donneur: un donneur est tiré aléatoirement parmi la liste 
des prétendants.
- en calculant une **distance** entre le receveur et l'ensemble des donneurs: un donneur est 
tiré parmi les individus avec lesquels la distance est la plus faible.

La première option nécessite d'utiliser uniquement des variables catégorielles, 
quitte à créer des classes pour les variables continues qu'on souhaiterait inclure 
dans la liste. 

Dans la pratique, cette première option est la moins gourmande en ressources de calcul, 
car elle ne nécessite pas de calculer une distance entre chaque receveur et chaque donneur potentiel. 
Elle est probablement la seule envisageable si le jeu de données contient plusieurs millions de lignes.


### Individus ou ménages ?

Une autre souplesse de la méthode est de pouvoir prendre en compte des 
structures hiérarchiques entre les individus. Par exemple, lorsque le fichier 
d'individus contient également des informations sur la composition des ménages. 

Dans ce cas, l'échange d'individus risque de déstabiliser la composition des 
ménages concernés, en termes d'âge en particulier: on pourrait voir se créer des 
ménages où il n'y a aucun individu majeur par exemple. 

Une solution consisterait à échanger des ménages entiers plutôt que des individus. 
Mais cette solution n'est à retenir que si on dispose de suffisamment d'informations 
sur les ménages pour détecter des ménages similaires de bonne qualité. 
Si ce n'est pas le cas, il peut être préférable d'échanger des individus et de contrôler 
d'une autre manière, car un choix judicieux de variables de similarité peut limiter ces 
désagréments.


:::: {.columns}

::: {.column width="45%"}

| Résidence | Sexe | Age | Statut    | Diplome | Catégorie<br>Sociale | Risque |
|-----------|------|-----|-----------|---------|----------------------|-------:|
| C1        | H    | 35  | Chômage   | Bac+2   | Employé              |      1 |
| C1        | F    | 40  | En emploi | Bac+5   | Cadre                |   0,05 |
| C1        | F    | 12  | Inactif   |         | Elève                |   0,05 |

: Composition du ménage 1 {.striped .hover}
:::

::: {.column width="5%"}
<!-- empty column to create gap -->
:::

::: {.column width="45%"}
| Résidence | Sexe | Age | Statut    | Diplome | Catégorie<br>Sociale | Risque |
|-----------|------|-----|-----------|---------|----------------------|-------:|
| C2        | H    | 55  | En emploi | Bac+5   | Cadre                |   0,05 |
| C2        | F    | 53  | En emploi | Bac+5   | Cadre                |   0,05 |
| C2        | H    | 17  | Inactif   | BEP     | Ouvrier              |   0,05 |

: Composition du ménage 2 {.striped .hover}
:::

::::



## Les grandes étapes à suivre pour appliquer le `TRS`

1. De quels risques cherche-t-on à se protéger ?
   1. Si c'est du risque de ré-identification, le `TRS` est une méthode adaptée
   2. Sinon, il faut peut-être aller voir ailleurs.
2. Quelles sont les variables quasi-identifiantes dans mes données ?
3. Mesurer le risque de ré-identification basé sur ces variables ? 
4. Choisir un seuil de risque de ré-identification maximal acceptable, au-delà duquel les individus devront être traités.
5. Quelles sont les marges que la méthode devrait conserver intactes en priorité ?
6. Un *swapping* des ménages est-il préférable à un swapping d'individus ? 
7. Sélectionner les variables de similarités, en tenant compte des risques et des objectifs de diffusion.
8. Procéder au swapping
9. Mesurer la perte d'information 
10. Reprendre les étapes 4. à 9. si la perte d'information s'avère trop grande ou la protection trop faible


L'avantage de la méthode  est sa grande capacité d'adaptation aux données dont on dispose. 
Même si cette fiche va présenter comment l'appliquer avec le package `sdcMicro`, il est en 
réalité tout à fait possible de développer sa propre solution 


On pourra se reporter à la [fiche sur les mesures de risque](pratique/fiches/mesurer-risque.html) 
pour en savoir plus sur les risques et la façon de les mesurer.









Pour installer les packages nécessaires, vous trouverez les instructions à suivre 
dans la fiche [Ressources / Installer les packages et les outils sur R](../../ressources/fiches/outils-install.html).  

```{r}
#| echo: false
library(readr)
library(purrr)
library(dplyr)
library(sdcMicro)
```

## Importons les données

```{r}
source("../R/fun_import_data.R")
lfs_2023 <- import_lfs()
```


```{r}
head(lfs_2023)
```

Pour plus d'informations sur les données, on pourra se reporter à la fiche 
["Présentation des données"](description-data.html).  


## Mesurons les risques du fichier

### Les types de variables

On définit les variables selon les différentes catégories suivantes:

- les variables quasi-identifiantes (`key_vars`)
- les variables sensibles (`sens_vars`)
- les variables identifiant la composition des ménages (`hhid_vars`)

Pour cet exercice, nous ferons les choix suivants:

```{r}
key_vars <- c("AGE","SEXE","DEP","DIP7")
sens_vars <- c("ACTEU","ANCCHOM")
hhid_vars <- c("HHID")
```


## Préparartion pour le swapping

```{r}
lfs_2023_pr_swap <- lfs_2023 %>% 
  mutate(across(everything(), as.integer)) %>% 
  mutate(
    REG = floor(DEP / 10),
    ID = 1:n()
  ) %>% 
  group_by(HHID) %>% 
  mutate(TAILLE = n()) %>% 
  ungroup() %>% 
  data.table::as.data.table()
```


```{r}
risk_variables <- c("AGE6","SEXE","ACTEU")
hierarchy <- c("REG", "DEP")
similar <- c("DIP7")
carry_along <- NULL
k_anonymity <- 1
swaprate <- .05


hid <- "ID" # swapping d'individus
```


### Swapper les individus


```{r}
lfs_swapped <- recordSwap(
  data = lfs_2023_pr_swap,
  hid = hid,
  hierarchy = hierarchy,
  similar = similar,
  risk_variables = risk_variables,
  carry_along = carry_along,
  k_anonymity = k_anonymity,
  swaprate = swaprate,
  return_swapped_id = TRUE,
  seed = 123456
)

lfs_swapped %>% summarise(mean(ID != ID_swapped)) #5%
lfs_swapped %>% group_by(REG) %>%
  summarise(mean(ID != ID_swapped)) #5%
```


#### Vérifier que les individus à risque ont bien été swappés


#### Intégrité de la composition des ménages



### Swapper les ménages


```{r}
hid <- "HHID" # swapping de ménages
similar <- "TAILLE"

lfs_swapped_hh <- recordSwap(
  data = lfs_2023_pr_swap,
  hid = hid,
  hierarchy = hierarchy,
  similar = similar,
  risk_variables = risk_variables,
  carry_along = carry_along,
  k_anonymity = k_anonymity,
  swaprate = swaprate,
  return_swapped_id = TRUE,
  seed = 123456
)
```


#### Taux de swapping des ménages vs taux de swapping des individus

```{r}
lfs_swapped_hh %>% summarise(mean(HHID != HHID_swapped)) #6.2 des ménages
lfs_swapped_hh %>% filter(HHID != HHID_swapped) %>%
  summarise(n()/nrow(lfs_swapped_hh)*100) #6.2% des individus (les ménages swappés sont de même taille)
lfs_swapped_hh %>% filter(HHID != HHID_swapped) %>%
  summarise(mean(TAILLE))

```

## Mesurer la perte d'utilité 


Comparer différents taux de swapping.

### Comparer les intervalles de confiance d'un modèle logistique

```{r}
source("../R/fun_cio.R")
```


Étudions la stabilité d'un modèle relativement simple, cherchant à expliquer 
le fait d'être au chômage par différentes variables à notre disposition:
l'âge, le diplôme et le sexe.

On entraînera ce modèle uniquement sur la population active. On retire donc notamment 
la population étudiante et retraitée.


```{r}
m_original <- glm(IS_CHOM ~ SEXE + AGE6 + DIP7, data = lfs_2023 |> filter(ACTEU != 3))
m_swapped <- glm(IS_CHOM ~ SEXE + AGE6 + DIP7, data = lfs_2023 |> filter(ACTEU != 3))

mes_modeles <- list(
  "original" = m_original,
  "swapped" = m_swapped
)

all_cios <- get_all_confints(mes_modeles)
```


```{r}
graph_cios(all_cios, titre = "Superposition des intervalles de confiance\ndes Odds Ratio du modèle selon le jeu de données") +
  theme(axis.text.y =  element_text(size = 8))
```

