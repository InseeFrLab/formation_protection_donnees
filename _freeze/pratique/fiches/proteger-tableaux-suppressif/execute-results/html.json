{
  "hash": "13b6e3a19f1ea8a2123aeab44eed4267",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Protéger des tableaux avec une méthode suppressive\n---\n\nCette fiche pratique présente une façon de protéger des tableaux en utilisant une méthode suppressive grâce au package `rtauargus` qui appelle Tau-Argus depuis R. Les données utilisées peuvent être générées à partir du document [INSERER LIEN]. Le code peut être entièrement caché ou visible grâce au bouton à droite du titre. Vous pouvez aussi le faire apparaître ou disparaître au fur et à mesure de la lecture en appuyant sur les boutons Code.\n\n# Initialisation\n\nInstallation du package rtauargus.\n\n::: {.cell}\n\n```{.r .cell-code}\nremotes::install_github(\n  'InseeFrLab/rtauargus',\n  dependencies = TRUE,\n  build_vignettes = FALSE,\n  upgrade = 'never',\n  ref = \"v-1.2.999-dev\"\n)\n```\n:::\n\n\n\nImport des packages.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(rtauargus)\n```\n:::\n\n\nModifier le chemin ci-dessous :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nloc_tauargus <- \"C:/Users/tmm7an/Documents/SDC/TauArgus/TauArgus4.2.5/TauArgus.exe\"\noptions(rtauargus.tauargus_exe = loc_tauargus)\n```\n:::\n\n\n# Tabuler les données\n\nPour faciliter le passage des microdonnées aux données tabulées une fonction est incluse dans `rtauargus` : `tabulate_micro_data()`.\n\nLes arguments de la fonction sont les suivants :\n\n- `df`: jeu de données individuelles (data.frame ou data.table)\n- `cat_vars`: variables de croisements (catégorielles) non hiérarchiques (vecteur)\n- `hrc_vars`: variables de croisements hiérarchiques sous la forme d'une liste nommée\n- `pond_var`: variable de pondération\n- `resp_var`: indicateur(s), variable(s) de réponse\n- `marge_label`: label utilisé pour les marges (sous-totaux)\n\n## Présentation des données individuelles\n\nNous créons un jeu de données entreprises (1 ligne = 1 entreprise) pour lesquelles \non dispose d'informations telles que l'activité, la catégorie juridique, \nla géographie d'implantation (variables NUTS) et la tranche d'effectifs. Pour \nchaque entreprise on dispose également du chiffre d'affaires (CA) selon le type de produits (salades, \npizzas, batavias, légumes rouges, etc.).\n\n\n::: {.cell}\n\n```{.r .cell-code}\na88 <- c(\"A01\",\"A02\",\"A03\",\"B05\",\"B06\",\"B07\",\"B08\",\"B09\",\"C10\",\"C11\",\"C12\",\"C13\",\n         \"C14\",\"C15\",\"C16\",\"C17\",\"C18\",\"C19\",\"C20\",\"C21\",\"C22\",\"C23\",\"C24\",\"C25\",\n         \"C26\",\"C27\",\"C28\",\"C29\",\"C30\",\"C31\",\"C32\",\"C33\",\"D35\",\"E36\",\"E37\",\"E38\",\n         \"E39\",\"F41\",\"F42\",\"F43\",\"G45\",\"G46\",\"G47\",\"H49\",\"H50\",\"H51\",\"H52\",\"H53\",\n         \"I55\",\"I56\",\"J58\",\"J59\",\"J60\",\"J61\",\"J62\",\"J63\",\"K64\",\"K65\",\"K66\",\"L68\",\n         \"M69\",\"M70\",\"M71\",\"M72\",\"M73\",\"M74\",\"M75\",\"N77\",\"N78\",\"N79\",\"N80\",\"N81\",\n         \"N82\",\"O84\",\"P85\",\"Q86\",\"Q87\",\"Q88\",\"R90\",\"R91\",\"R92\",\"R93\",\"S94\",\"S95\",\n         \"S96\",\"T97\",\"T98\",\"U99\")\n\ncorrespondance_naf <- data.frame(a88) %>% \n  mutate(a21 = substr(a88,1,1),\n         a10 = case_when(\n           a21 == \"A\" ~ \"AZ\",\n           a21 %in% c(\"B\",\"C\",\"D\",\"E\") ~ \"BE\",\n           a21 == \"F\" ~ \"FZ\",\n           a21 %in% c(\"G\",\"H\",\"I\") ~ \"GI\",\n           a21 == \"J\" ~ \"JZ\",\n           a21 == \"K\" ~ \"KZ\",\n           a21 == \"L\" ~ \"LZ\",\n           a21 %in% c(\"M\",\"N\") ~ \"MN\",\n           a21 %in% c(\"O\",\"P\",\"Q\") ~ \"OQ\",\n           a21 %in% c(\"R\",\"S\",\"T\",\"U\") ~ \"RU\"\n         )) %>% \n  select(a10,a21,a88)\n\nnuts3 <- c(\"FR101\",\"FR102\",\"FR103\",\"FR104\",\"FR105\",\"FR106\",\"FR107\",\"FR108\",\"FRB01\",\n           \"FRB02\",\"FRB03\",\"FRB04\",\"FRB05\",\"FRB06\",\"FRC11\",\"FRC12\",\"FRC13\",\"FRC14\",\n           \"FRC21\",\"FRC22\",\"FRC23\",\"FRC24\",\"FRD11\",\"FRD12\",\"FRD13\",\"FRD21\",\"FRD22\",\n           \"FRE11\",\"FRE12\",\"FRE21\",\"FRE22\",\"FRE23\",\"FRF11\",\"FRF12\",\"FRF21\",\"FRF22\",\n           \"FRF23\",\"FRF24\",\"FRF31\",\"FRF32\",\"FRF33\",\"FRF34\",\"FRG01\",\"FRG02\",\"FRG03\",\n           \"FRG04\",\"FRG05\",\"FRH01\",\"FRH02\",\"FRH03\",\"FRH04\",\"FRI11\",\"FRI12\",\"FRI13\",\n           \"FRI14\",\"FRI15\",\"FRI21\",\"FRI22\",\"FRI23\",\"FRI31\",\"FRI32\",\"FRI33\",\"FRI34\",\n           \"FRJ11\",\"FRJ12\",\"FRJ13\",\"FRJ14\",\"FRJ15\",\"FRJ21\",\"FRJ22\",\"FRJ23\",\"FRJ24\",\n           \"FRJ25\",\"FRJ26\",\"FRJ27\",\"FRJ28\",\"FRK11\",\"FRK12\",\"FRK13\",\"FRK14\",\"FRK21\",\n           \"FRK22\",\"FRK23\",\"FRK24\",\"FRK25\",\"FRK26\",\"FRK27\",\"FRK28\",\"FRL01\",\"FRL02\",\n           \"FRL03\",\"FRL04\",\"FRL05\",\"FRL06\",\"FRM01\",\"FRM02\",\"FRY10\",\"FRY20\",\"FRY30\",\n           \"FRY40\",\"FRY50\")\n\ncorrespondance_nuts <- data.frame(nuts3) %>% \n  mutate(nuts1 = substr(nuts3,1,3),\n         nuts2 = substr(nuts3,1,4)) %>% \n  select(nuts1,nuts2,nuts3)\n\nset.seed(123)\n\nn <- 10000  # nombre d’observations souhaité\n\nmicro <- tibble(\n  a88 = sample(a88, n, replace = TRUE),\n  nuts3 = sample(nuts3, n, replace = TRUE),\n  treff = sample(c(\"tr1\", \"tr2\", \"tr3\"), n, replace = TRUE),\n  cj = sample(c(\"LL\", \"PA\", \"SP\"), n, replace = TRUE),\n  maches = ifelse(runif(n) < 0.1, 0, round(runif(n, 30000, 75000))),\n  batavias = ifelse(runif(n) < 0.1, 0, round(runif(n, 25000, 70000))),\n  salades = maches + batavias,\n  tomates = ifelse(runif(n) < 0.08, 0, round(runif(n, 50000, 500000))),\n  pizzas = ifelse(runif(n) < 0.2, 0, round(runif(n, 60000, 900000))),\n  poids = round(runif(n, 1, 300))\n) %>%\n  left_join(correspondance_naf, by = \"a88\") %>%\n  left_join(correspondance_nuts, by = \"nuts3\") %>% \n  select(a10,a21,a88,nuts1,nuts2,nuts3,treff,cj,maches,batavias,salades,tomates,pizzas,poids)\n\nstr(micro)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ntibble [10,000 × 14] (S3: tbl_df/tbl/data.frame)\n $ a10     : chr [1:10000] \"BE\" \"RU\" \"JZ\" \"BE\" ...\n $ a21     : chr [1:10000] \"C\" \"R\" \"J\" \"C\" ...\n $ a88     : chr [1:10000] \"C32\" \"R90\" \"J58\" \"C15\" ...\n $ nuts1   : chr [1:10000] \"FRY\" \"FRH\" \"FRJ\" \"FRC\" ...\n $ nuts2   : chr [1:10000] \"FRY2\" \"FRH0\" \"FRJ1\" \"FRC1\" ...\n $ nuts3   : chr [1:10000] \"FRY20\" \"FRH01\" \"FRJ15\" \"FRC12\" ...\n $ treff   : chr [1:10000] \"tr1\" \"tr2\" \"tr2\" \"tr2\" ...\n $ cj      : chr [1:10000] \"SP\" \"LL\" \"SP\" \"LL\" ...\n $ maches  : num [1:10000] 31232 51295 68511 43158 53888 ...\n $ batavias: num [1:10000] 45495 53191 33912 0 65752 ...\n $ salades : num [1:10000] 76727 104486 102423 43158 119640 ...\n $ tomates : num [1:10000] 85455 299193 0 181815 444939 ...\n $ pizzas  : num [1:10000] 0 507705 0 420221 0 ...\n $ poids   : num [1:10000] 51 141 259 257 298 18 32 69 160 166 ...\n```\n\n\n:::\n:::\n\n\n\n## Tabuler un indicateur\n\nOn veut construire le chiffre d'affaires en salades des entreprises par activité (niveau a88) et par tranche d'effectifs (treff).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsalades <- tabulate_micro_data(\n  df = micro,\n  cat_var = c(\"a88\", \"treff\"),\n  pond_var = \"poids\",\n  resp_var = \"salades\",\n  marge_label = \"Ensemble\"\n)\n```\n:::\n\n\nLe résultat est un tableau long avec :\n\n* Les variables de croisement (a88 et treff)\n* Différents indicateurs :\n    + `nb_obs`: comptage du nombre d'entreprises (pour appliquer la règle de fréquence)\n    + `salades_tot`: indicateur / variable de réponse (ici total du chiffre d'affaire de salades)\n    + `salades_max`: contribution maximale au chiffre d'affaires (pour appliquer la règle de dominance)\nToutes les marges (totaux et sous-totaux) ont été ajoutées à la table.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(salades)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nClasses 'data.table' and 'data.frame':\t356 obs. of  5 variables:\n $ a88        : chr  \"C32\" \"R90\" \"J58\" \"C15\" ...\n $ treff      : chr  \"Ensemble\" \"Ensemble\" \"Ensemble\" \"Ensemble\" ...\n $ nb_obs     : num  18386 19493 20565 18310 18919 ...\n $ salades_tot: num  1.70e+09 1.75e+09 1.86e+09 1.65e+09 1.72e+09 ...\n $ salades_max: num  142485 136772 143623 135589 135581 ...\n - attr(*, \".internal.selfref\")=<externalptr> \n```\n\n\n:::\n:::\n\n\n## Calculer plusieurs indicateurs en même temps\n\nOn veut construire deux tableaux :  \n\n* le chiffre d'affaires de la production de pizzas des entreprises par activité (niveau A10), \npar tranche d'effectifs (treff) et catégorie juridique (cj);\n* le chiffre d'affaires de la production de tomates des entreprises par activité (niveau A10), \npar tranche d'effectifs (treff) et catégorie juridique (cj).\n\nCes deux tableaux ont les mêmes variables de croisement et deux indicateurs \ndifférents. Ils peuvent être construits en même temps.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nres_all_dtp <- tabulate_micro_data(\n  df = micro,\n  cat_vars = c(\"a10\", \"treff\",\"cj\"),\n  pond_var = \"poids\",\n  resp_var = c(\"pizzas\",\"tomates\"),\n  marge_label = \"Total\"\n)\n\nstr(res_all_dtp)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nClasses 'data.table' and 'data.frame':\t176 obs. of  8 variables:\n $ a10        : chr  \"BE\" \"RU\" \"JZ\" \"MN\" ...\n $ treff      : chr  \"Total\" \"Total\" \"Total\" \"Total\" ...\n $ cj         : chr  \"Total\" \"Total\" \"Total\" \"Total\" ...\n $ nb_obs     : num  589777 170400 106658 226737 166898 ...\n $ pizzas_tot : num  2.26e+11 6.65e+10 4.23e+10 8.34e+10 6.30e+10 ...\n $ tomates_tot: num  1.50e+11 4.30e+10 2.60e+10 5.78e+10 4.28e+10 ...\n $ pizzas_max : num  899556 896464 898695 899954 899982 ...\n $ tomates_max: num  499927 499670 499816 499971 499352 ...\n - attr(*, \".internal.selfref\")=<externalptr> \n```\n\n\n:::\n:::\n\n\n# Poser le secret primaire\n\n**Objectif** : détecter les cellules ne respectant pas les règles de confidentialité\ndans les tableaux proposés.\n\n**Consignes** : vous utiliserez les règles en vigueur à l'Insee pour la diffusion des\ntableaux issus des enquêtes entreprises.\n\n1.  Pour chacun des tableaux, vous ajouterez une variable booléenne\n    indiquant si la cellule est problématique (`TRUE`) ou non (`FALSE`),\n    au regard de chacune des règles pertinentes à appliquer:\n    \n-   Si vous appliquez la règle de fréquence, la variable créée\n    s'appellera `is_secret_freq`;\n-   Si vous appliquez la règle de dominance, la variable créée\n    s'appellera `is_secret_dom`.\n\n2.  Après avoir posé le secret, vous calculerez le nombre de cellules\n    détectées comme à risque.\n\nLe tableau `salades` est un tableau de volumes (CA), les règles de fréquence\net de dominance s'appliquent. D'après la jurisprudence Insee sur la\ndiffusion des données entreprises, le seuil de fréquence est fixé à 3 et\nle plus gros contributeur ne doit pas contribuer à plus de 85% de la\ncellule.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsalades_detect <- salades %>%\n    mutate(\n      is_secret_freq = nb_obs > 0 & nb_obs < 3,\n      is_secret_dom = (salades_tot != 0) & (salades_max > 0.85*salades_tot)\n    )\n\nsalades_detect %>% count(is_secret_freq, is_secret_dom)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   is_secret_freq is_secret_dom     n\n           <lgcl>        <lgcl> <int>\n1:          FALSE         FALSE   356\n```\n\n\n:::\n:::\n\n\n# Protéger un tableau simple\n\n**Objectif** : protéger un tableau simple en appelant Tau-Argus depuis R pour poser le secret secondaire.\n\n**Consignes** : vous utiliserez les règles en vigueur à l'Insee pour la diffusion des\ntableaux issus des enquêtes entreprises.\n\n## Poser le secret secondaire\n\nPoser un masque de secret sur un tableau comprend les étapes suivantes:\n\n1. Tout d'abord on pose le secret primaire. Pour cela, il faut créer créer des variables indicatrices :\n   1. Pour chacun des tableaux, vous ajouterez une variable booléenne indiquant si la cellule est problématique (`TRUE`) ou non (`FALSE`), au regard de chacune des règles pertinentes à appliquer :\n      - Si vous appliquez la règle de fréquence, la variable créée s'appellera `is_secret_freq`;\n      - Si vous appliquez la règle de dominance, la variable créée s'appellera `is_secret_dom`.\n   2. Puis de créer une variable qu'on appellera `is_secret_prim`, définie ainsi :\n      - `is_secret_prim = is_secret_freq` si seule la règle de fréquence doit s'appliquer;\n      - `is_secret_prim = is_secret_freq | is_secret_dom` si les deux règles doivent s'appliquer;\n2. Après avoir posé le secret primaire, vous calculerez le nombre de cellules détectées comme à risque.\n3. Ensuite, il s'agit de poser le secret secondaire en utilisant le package `rtauargus`. Les consignes d'installation de `rtauargus` et du logiciel Tau-Argus sont indiquées dans le fichier [INSERER LIEN]. Vous utiliserez notamment la fonction `tab_rtauargus()` et suivrez les étapes mentionnées pour apprendre à l'utiliser.\n4. Enfin, vous calculerez le nombre de cellules selon leur statut final. Nous utiliserons pour cela la norme européenne en notant :\n  - `A` les cellules en secret primaire à cause de la règle de fréquence\n  - `B` les cellules en secret primaire à cause de la règle de dominance (dans le futur ces cellules pourraient être notées `O`)\n  - `D` les cellules concernées par le secret secondaire\n  - `V` les cellules non touchées par le secret, cad les cellules qui pourront être diffusées.\n\nLa fonction `tab_rtauargus()` permet de poser le secret secondaire et requiert les arguments suivants :  \n  - `tabular` : la table à protéger\n  - `dir_name` : le nom du répertoire où  les fichiers seront sauvegardés\n  - `files_name` : le nom utilisé pour nommer les fichiers (chaque fichier a une extension différente);\n  - `explanatory_vars` : le nom des variables de croisements présents dans la table;\n  - `secret_var` : le nom de la variable indiquant si une cellule est à risque ou non (secret primaire);\n  - `value` : nom de la variable de réponse;\n  - `freq` : nom de la variable d'effectifs;\n  - `totcode` : le code utilisé pour indiquer le total pour chacune des variables de croisements (`explanatory_vars`).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsalades_masq <- tab_rtauargus(\n  salades_detect,\n  dir_name = \"tauargus_files/exo2\",\n  files_name = \"T0\",\n  explanatory_vars = c(\"a88\",\"treff\"),\n  secret_var = \"is_secret_prim\",\n  value = \"salades_tot\",\n  freq = \"nb_obs\",\n  totcode = c(a88=\"Total\",treff=\"Total\"),\n  verbose = FALSE\n)\n```\n:::\n\n\n## Analyser les résultats\n\n### Les fichiers créés lors de l'exécution de Tau-Argus\n\nL'ensemble des fichiers créés pendant le processus se trouvent dans le répertoire\nmentionné dans l'argument `dir_name`. Tous les fichiers ont le même nom,\nmais pas la même extension:\n\n- `T0.tab` : tableau de données\n- `T0.hst` : fichier d'apriori où sont listées les cellules à risque (secret primaire)\n- `T0.rda` : fichier de métadonnées;\n- `T0.arb` : fichier batch, qui sera exécuté par Tau-Argus\n- `T0.txt` : fichier log, retraçant les étapes exécutées par Tau-Argus\n- `T0.csv` : masque au format csv\n\n### Le masque\n\nLe masque est retourné par la fonction. Ce masque est une copie de la table fournie en entrée à laquelle une variable supplémentaire, `Status`, est fournie indiquant \nle statut final de la cellule: \n\n- `B` : secret primaire (ou apriori)\n- `D` : secret secondaire\n- `V` : cellule valide, cad qui peut être diffusée\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(T0_masq)\n```\n:::\n\n\n### Bilan du secret\n\nPour faire le bilan du secret le mieux est de modifier la variable `Status` \nfournie par Tau-Argus. En effet, cette variable ne permet pas de faire la \ndistinction entre l'origine du secret primaire (fréquence ou dominance).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nT0_masq <- T0_masq %>% \n  mutate(\n    statut_final = case_when(\n      is_secret_freq ~ \"A\",\n      is_secret_dom ~ \"B\",\n      TRUE ~ Status,\n    )\n  )\n```\n:::\n\n\n\nAfin de bien appréhender l'impact du secret posé, on va non seulement compter\nle nombre de cellules masquées, mais aussi calculer la valeur des cellules masquées.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nT0_masq %>% \n  group_by(statut_final) %>% \n  summarise(\n    n_cell = n(),\n    val_cell = sum(VALUE)\n  ) %>%\n  mutate(\n    pc_n_cell = n_cell/sum(n_cell)*100,\n    pc_val_cell = val_cell/sum(val_cell)*100\n  )\n```\n:::\n\n\nOn masque 1/3 des cellules mais seulement 12% de l'information totale.\n\n# Protéger un tableau hiérarchique\n\n**Objectifs** : comprendre la notion de variables hiérarchiques et savoir manipuler les objets et \nfichiers argus qui y sont associés. Pour ensuite, protéger un tableau contenant une ou plusieurs variables hiérarchiques\nen appelant Tau-Argus depuis R pour poser le secret secondaire.\n\nReprenons l'exemple présenté dans le diaporama:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nT0 <- data.frame(\n  geo = c(\"Pays\",\"Nord\",\"Ouest\",\"Est\",\"Sud\",paste0(\"N\",1:3),paste0(\"O\",1:4),paste0(\"E\",1:3), paste0(\"S\",1:2)),\n  freq = c(400, 46, 191, 80, 83, 21, 2, 23, 32, 54, 67, 38, 27, 41, 12, 44, 39)\n)\nstr(T0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n'data.frame':\t17 obs. of  2 variables:\n $ geo : chr  \"Pays\" \"Nord\" \"Ouest\" \"Est\" ...\n $ freq: num  400 46 191 80 83 21 2 23 32 54 ...\n```\n\n\n:::\n:::\n\n\nLa variable `geo` est une variable hiérarchique puisqu'il existe des emboîtements \nentre les différents niveaux :  \n\n- Pays = Nord + Ouest + Est + Sud\n- Nord = N1 + N2 + N3\n- Ouest = O1 + O2 + O3 + O4\n- Est = E1 + E2 + E3\n- Sud = S1 + S2\n\n\nAvant de penser à protéger un tel tableau, il faut pouvoir représenter correctement \ncette hiérarchie, c'est-à-dire de telle sorte que tau-argus sache comprendre les différents\nemboîtements présents.\n\n## Construction du fichier hiérarchique pour Tau-Argus\n### \"A la main\"\nLa première option consiste à créer le fichier nécessaire (extension .hrc) à la main.\nCeci est tout à fait pertinent si la hiérarchie n'est pas trop étendue.\n\nTau-Argus attend en effet un type de fichier bien particulier, dont l'extension \nest `.hrc`. Il s'agit d'un simple fichier texte où les différents emboîtements \nsont écrits les uns en-dessous des autres. Un symbole (le `@`) est utilisé pour \npréciser le niveau de chacun des emboîtements au sein de la hiérarchie.\n\nPar exemple, un fichier contenant les lignes suivantes :\n\nALL  \n@A  \n@@A1  \n@@A2  \n@B  \n@@B1  \n@@B2  \n@@@B21  \n@@@B22  \n@C  \n\n\ndécrit une hiérarchie contenant les emboîtements suivants:  \n\n- ALL = A + B + C => ALL est le total et A, B et C sont les emboîtements de niveau 1;\n- A = A1 + A2 => A1 et A2 sont des sous-niveaux de A, donc des emboîtements de niveau 2;\n- B = B1 + B2\n- B2 = B21 + B22\n\nNéanmoins, pour utiliser cette hiérarchie avec Tau-Argus, **le super-total (ici \"ALL\")\nne doit pas apparaître dans le fichier .hrc** qui lui est fourni.\n\nLe bon fichier est donc le suivant :\n\n@A  \n@@A1  \n@@A2  \n@B  \n@@B1  \n@@B2  \n@@@B21  \n@@@B22  \n@C  \n\n\n### Automatiquement\n\nQuand la hiérarchie est très étendue, l'écriture manuelle du fichier de hiérarchie \nest pénible. Or, quand ce genre de cas se présente, il existe souvent une table \nde correspondance permettant d'associer les différents niveaux entre eux.\n\nNous appelons table de correspondance une table qui précise l'ensemble des niveaux \nassociés aux emboîtements les plus fins.\n\nLa table de correspondance représentant la hiérarchie suivante :\n\nALL  \n@A  \n@@A1  \n@@A2  \n@B  \n@@B1  \n@@B2  \n@@@B21  \n@@@B22  \n@C  \n\nest la suivante:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncorr_tab <- tibble(\n  niv0 = \"ALL\",\n  niv1 = c(rep(\"A\",2),rep(\"B\",3), \"C\"),\n  niv2 = c(\"A1\",\"A2\",\"B1\",rep(\"B2\",2), \"C\"),\n  niv3 = c(\"A1\",\"A2\",\"B1\", \"B21\", \"B22\", \"C\")\n)\ncorr_tab\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 4\n  niv0  niv1  niv2  niv3 \n  <chr> <chr> <chr> <chr>\n1 ALL   A     A1    A1   \n2 ALL   A     A2    A2   \n3 ALL   B     B1    B1   \n4 ALL   B     B2    B21  \n5 ALL   B     B2    B22  \n6 ALL   C     C     C    \n```\n\n\n:::\n:::\n\n\nRemarque: La fonction `rtauargus::write_hrc2()` qui permet de construire le fichier `.hrc` \nà partir d'une table de correspondance n'accepte pas de valeurs manquantes dans \nla table en entrée. C'est pourquoi, à la dernière ligne, par exemple, `C` \nn'admettant pas de subdivisions est répété sur les niveaux inférieurs.\n\nAvec la fonction `write_hrc2()` du package `rtauargus`, on peut exporter la \ntable de correspondance en un fichier `hrc`.\nComme noté précédemment, Tau-Argus n'acceptant pas que le super-total d'une variable \nhiérarchique soit présent dans le fichier `.hrc` on le supprime:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_hrc2(corr_tab %>% select(-niv0), file_name = \"fichiers_tauargus/hrc/exemple_TA.hrc\")\nread.table(\"fichiers_tauargus/hrc/exemple_TA.hrc\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     V1\n1     A\n2   @A1\n3   @A2\n4     B\n5   @B1\n6   @B2\n7 @@B21\n8 @@B22\n9     C\n```\n\n\n:::\n:::\n\n\n\n## Protection\nA présent nous protégeons le tableau T0 pour lequel on vient de construire la hiérarchie.\n\nLa variable `geo` est hiérarchique (Pays = Nord + Ouest + Est + Sud, par exemple), on construit le fichier adéquat.\n\nTable de passage (habituellement elle existe déjà mais pour l'exercice nous la créons) et appel à `rtauargus::write_hrc2()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncorr_pays <- tibble(\n  niv1 = c(rep(\"Nord\", 3), rep(\"Ouest\", 4), rep(\"Est\", 3), rep(\"Sud\", 2)),\n  niv2 = c(\"N1\", \"N2\", \"N3\", \"O1\", \"O2\", \"O3\", \"O4\", \"E1\", \"E2\", \"E3\", \"S1\", \"S2\")\n)\n\nwrite_hrc2(corr_pays, file_name = \"fichiers_tauargus/hrc/pays.hrc\")\nread.table(\"fichiers_tauargus/hrc/pays.hrc\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      V1\n1   Nord\n2    @N1\n3    @N2\n4    @N3\n5  Ouest\n6    @O1\n7    @O2\n8    @O3\n9    @O4\n10   Est\n11   @E1\n12   @E2\n13   @E3\n14   Sud\n15   @S1\n16   @S2\n```\n\n\n:::\n:::\n\n\n\nNous pouvons dès lors poser le masque de secret sur ce tableau. Pour cela, nous faisons toujours appel à la fonction `tab_rtauargus`.\n\n### 1. Poser le secret primaire\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(T0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n'data.frame':\t17 obs. of  2 variables:\n $ geo : chr  \"Pays\" \"Nord\" \"Ouest\" \"Est\" ...\n $ freq: num  400 46 191 80 83 21 2 23 32 54 ...\n```\n\n\n:::\n:::\n\n\nIl s'agit d'un tableau d'effectifs/de fréquence, on pose donc seulement le secret primaire de fréquence.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nT0_detect <- T0 %>% \n  mutate(\n      is_secret_freq = freq > 0 & freq < 3\n    )\n\ntable(T0_detect$is_secret_freq)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nFALSE  TRUE \n   16     1 \n```\n\n\n:::\n:::\n\n\n### 2. Lancer Tau-Argus pour poser le secret secondaire\n\nPour que l'information hiérarchique soit bien prise en compte lors de la pose du\nsecret secondaire par Tau-Argus, il suffit de renseigner l'argument `hrc = ` \nsous la forme d'un vecteur nommé `c(var1 = fichier1, var2 = fichier2,...)`:\nle nom de chaque élément étant le nom de la variable concernée et la valeur étant \nla localisation du fichier `.hrc` correspondant.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nT0_masq <- tab_rtauargus(\n  T0_detect,\n  dir_name = \"fichiers_tauargus/sorties/ex_hrc_pays\",\n  files_name = \"T0\",\n  explanatory_vars = \"geo\",\n  hrc = c(geo = \"fichiers_tauargus/hrc/pays.hrc\"),\n  secret_var = \"is_secret_freq\",\n  value = \"freq\",\n  totcode = c(geo=\"Pays\"),\n  verbose = FALSE\n)\n\nT0_masq %>% count(Status)\n```\n:::\n\n\nVérifions que le secret a été posé correctement : \n\n\n::: {.cell}\n\n```{.r .cell-code}\nT0_masq\n```\n:::\n\n\nLa cellule N2 est en secret primaire car elle a une fréquence inférieure à 3. Il faut donc poser un secret secondaire pour protéger cette cellule. On voit que N1 est en secret secondaire ce qui permet de protéger N2 de la différenciation avec le total Nord. Donc, on a bien ici une pose de secret qui respecte la hiérarchie de la variable `geo`.\n\nRegardons à présent le secret posé sans prendre en compte la hiérarchie sur la variable `geo` :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nT0_masq_sans_hrc <- tab_rtauargus(\n  T0_detect,\n  dir_name = \"fichiers_tauargus/sorties/ex_hrc_pays\",\n  files_name = \"T0\",\n  explanatory_vars = \"geo\",\n  # hrc = c(geo = \"fichiers_tauargus/hrc/pays.hrc\"),\n  secret_var = \"is_secret_freq\",\n  value = \"freq\",\n  totcode = c(geo=\"Pays\"),\n  verbose = FALSE\n)\n\nT0_masq_sans_hrc\n```\n:::\n\n\nCette fois-ci le secret secondaire est posé en E3, pour minimiser les valeurs supprimées.\nMais ce secret ne tient pas car on peut retrouver la valeur de N2 en faisant N2 = Nord - N1.\n\n# Protéger des tableaux liés\n\nLorsque l'on souhaite publier plusieurs tableaux il faut suivre une démarche permettant de les protéger de manière cohérente. En effet, il faut identifier les cellules communes entre les tableaux afin de préciser leur existence à `rtauargus` qui se chargera de la cohérence du secret.\n\nVoici la démarche à suivre :\n- détecter les cellules communes entre les tableaux à partir des métadonnées\n- tabuler les données et construire les hiérarchies nécessaires\n- poser le secret primaire\n- créer des listes de tableaux indépendantes (une liste = un cluster)\n- poser le secret secondaire avec `rtauargus::tab_multi_manager()`\n\n## Analyser la demande\n\nA partir des microdonnées présentées dans la partie \"Tabuler les données\", on souhaite publier les tableaux suivants.\n\n\n::: {.cell as-is='true'}\n::: {.cell-output-display}\n\n\n|Tab |Var_reponse |expl_var1 |expl_var2 |\n|:---|:-----------|:---------|:---------|\n|T1  |ca_pizzas   |Nuts2     |TREFF     |\n|T2  |ca_pizzas   |Nuts3     |TREFF     |\n|T3  |ca_pizzas   |A10       |Nuts2     |\n|T4  |ca_pizzas   |A10       |Nuts3     |\n|T5  |ca_pizzas   |A21       |Nuts2     |\n|T6  |ca_pizzas   |A21       |Nuts3     |\n|T7  |ca_pizzas   |A88       |Nuts2     |\n|T8  |ca_pizzas   |A88       |Nuts3     |\n|T9  |ca_batavia  |A10       |TREFF     |\n|T10 |ca_batavia  |A10       |CJ        |\n|T11 |ca_batavia  |A21       |TREFF     |\n|T12 |ca_batavia  |A21       |CJ        |\n|T13 |ca_batavia  |A88       |TREFF     |\n|T14 |ca_batavia  |A88       |CJ        |\n|T15 |ca_mache    |A10       |TREFF     |\n|T16 |ca_mache    |A10       |CJ        |\n|T17 |ca_mache    |A21       |TREFF     |\n|T18 |ca_mache    |A21       |CJ        |\n|T19 |ca_mache    |A88       |TREFF     |\n|T20 |ca_mache    |A88       |CJ        |\n|T21 |ca_salades  |A10       |TREFF     |\n|T22 |ca_salades  |A10       |CJ        |\n|T23 |ca_salades  |A21       |TREFF     |\n|T24 |ca_salades  |A21       |CJ        |\n|T25 |ca_salades  |A88       |TREFF     |\n|T26 |ca_salades  |A88       |CJ        |\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\nChamp de la population : entreprises françaises.\nInformations complémentaires : il n'y a que deux types de salades les batavias et la mâche.\n```\n\n\n:::\n:::\n\n\nPour n'oublier aucun lien entre les tableaux, on procède étape par étape.\n\n### Les tableaux sont-ils sur le même champ ?\nOui les tableaux portent tous sur le même champ des entreprises françaises.\n\n### Les tableaux ont-ils les mêmes variables réponses ?\n- T1-T8 : variable réponse « ca_pizzas »\n- T9-T14 : variable réponse « ca_batavia »\n- T15-T20 : variable réponse « ca_mache »\n- T21-T26 : variable réponse « ca_salades »\n\n### Les variables réponses ont-elles un lien entre elles ?\nL’information complémentaire nous identique qu’il n’y a que deux types de salades, les batavias et la mâche. On comprend donc que la somme des chiffres d’affaires des batavias et des mâches est égale au chiffre d’affaires des salades : ca_salades = ca_batavia + ca_mache.\nOn peut donc regrouper tous les tableaux qui ont les mêmes variables de croisement et l’un de ces trois indicateurs dans un même tableau. Dans ce tableau on crée une nouvelle variable de croisement qu’on peut nommer « crois_salades ». C’est le cas pour les tables de 9 à 26, on peut les regrouper comme suit : \n- T9_T15_T21 : ca $\\otimes$ {A10 x treff x crois_salades}  \n- T10_T16_T22 : ca $\\otimes$ {A10 x cj x crois_salades}  \n- T11_T17_T23 : ca $\\otimes$ {A21 x treff x crois_salades}  \n- T12_T18_T24 : ca $\\otimes$ {A21 x cj x crois_salades}  \n- T13_T19_T25 : ca $\\otimes$ {A88 x treff x crois_salades}  \n- T14_T20_T26 : ca $\\otimes$ {A88 x cj x crois_salades}  \n\nOn en déduit donc qu’il y a deux sous-demandes indépendantes / « clusters » : \n- T1-T8 (cluster pizza)  \n- T9-T26 (cluster salades) \n\n### Dans chacun des clusters variables de croisement identiques ?\nDans chacun des clusters y a-t-il des variables de croisement identiques ? Y a-t-il des variables de croisements liés par un lien hiérarchique ?\nCluster pizza :  \n- les variables « nuts2 » et « nuts3 » font partie de la même hiérarchie « nuts », autrement dit une hiérarchie sur la zone géographique  \n- les variables A10, A21 et A88 font partie de la hiérarchie « NAF »  \n\nOn peut donc regrouper ces variables de croisement en deux variables de croisement « nuts » et « NAF ». On obtient donc 2 tableaux à protéger dans le cluster pizza :  \n- T_A : ca_pizzas $\\otimes$ {nuts x treff}  \n- T_B : ca_pizzas $\\otimes$ {naf x nuts}\n\nCes deux tableaux sont liés par leur marge sur nuts. Il faut les traiter ensemble dans le même `tab_multi_manager()`.\n\nCluster salades :\n- les variables A10, A21 et A88 font partie de la hiérarchie « NAF »\n\nAinsi, on peut réecrire les 6 tableaux écrits plus haut de cette façon :  \n- T9_T15_T21 : ca $\\otimes$ {naf x treff x crois_salades}  \n- T10_T16_T22 : ca $\\otimes$ {naf x cj x crois_salades}  \n- T11_T17_T23 : ca $\\otimes$ {naf x treff x crois_salades}  \n- T12_T18_T24 : ca $\\otimes$ {naf x cj x crois_salades}  \n- T13_T19_T25 : ca $\\otimes$ {naf x treff x crois_salades}  \n- T14_T20_T26 : ca $\\otimes$ {naf x cj x crois_salades}  \n\nOn voit bien que plusieurs de ces tableaux sont en fait exactement les mêmes, donc finalement les tableaux à traiter pour ce cluster sont : \n- T_C : ca $\\otimes$ {naf x treff x crois_salades}  \n- T_D: ca $\\otimes$ {naf x cj x crois_salades}  \n\n## Tabuler les données\n\nOn commence par tabuler les données pour l'indicateur \"chiffre d'affaires vente pizzas\".\n\n::: {.cell}\n\n```{.r .cell-code}\npizzas_tabule <- tabulate_micro_data(\n  micro,\n  cat_vars = c(\"treff\"),\n  hrc_vars = list(naf = c(\"a10\",\"a21\",\"a88\"), nuts = c(\"nuts2\",\"nuts3\")),\n  pond_var = \"poids\",\n  resp_var = c(\"pizzas\"),\n  marge_label = \"Total\"\n)\n\nstr(pizzas_tabule)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nClasses 'data.table' and 'data.frame':\t34863 obs. of  6 variables:\n $ naf       : chr  \"BE\" \"RU\" \"JZ\" \"MN\" ...\n $ nuts      : chr  \"Total\" \"Total\" \"Total\" \"Total\" ...\n $ treff     : chr  \"Total\" \"Total\" \"Total\" \"Total\" ...\n $ nb_obs    : num  589777 170400 106658 226737 166898 ...\n $ pizzas_tot: num  2.26e+11 6.65e+10 4.23e+10 8.34e+10 6.30e+10 ...\n $ pizzas_max: num  899556 896464 898695 899954 899982 ...\n - attr(*, \".internal.selfref\")=<externalptr> \n```\n\n\n:::\n:::\n\n\nOn tabule ensuite pour les indicateurs \"chiffre d'affaires vente mâches, batavia et salades\". N.B. il faut créer une nouvelle variable de croisement.\n\n::: {.cell}\n\n```{.r .cell-code}\nsalades_tabule <- tabulate_micro_data(\n  micro,\n  cat_vars = c(\"treff\",\"cj\"),\n  hrc_vars = list(naf = c(\"a10\",\"a21\",\"a88\")),\n  pond_var = \"poids\",\n  resp_var = c(\"salades\",\"batavias\",\"maches\"),\n  marge_label = \"Total\"\n)\n\nsalades_tabule_3var <- salades_tabule %>% \n  tidyr::pivot_longer(\n    cols = c(salades_tot, maches_tot, batavias_tot, \n             salades_max, maches_max, batavias_max),\n    names_to = c(\"crois_salades\", \".value\"),\n    names_pattern = \"(.*)_(tot|max)\"\n  )\n\nstr(salades_tabule_3var)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ntibble [5,760 × 7] (S3: tbl_df/tbl/data.frame)\n $ naf          : chr [1:5760] \"BE\" \"BE\" \"BE\" \"RU\" ...\n $ treff        : chr [1:5760] \"Total\" \"Total\" \"Total\" \"Total\" ...\n $ cj           : chr [1:5760] \"Total\" \"Total\" \"Total\" \"Total\" ...\n $ nb_obs       : num [1:5760] 589777 589777 589777 170400 170400 ...\n $ crois_salades: chr [1:5760] \"salades\" \"maches\" \"batavias\" \"salades\" ...\n $ tot          : num [1:5760] 5.32e+10 2.76e+10 2.56e+10 1.54e+10 8.12e+09 ...\n $ max          : num [1:5760] 143880 74997 69985 142663 74949 ...\n```\n\n\n:::\n:::\n\n\n## Poser le secret primaire\n\nSecret primaire pour les pizzas.\n\n::: {.cell}\n\n```{.r .cell-code}\npizzas_tabule <- pizzas_tabule %>% mutate(\n  is_secret_freq = nb_obs > 0 & nb_obs < 3,\n  is_secret_dom = (pizzas_tot != 0) & (pizzas_max > 0.85*pizzas_tot),\n  is_secret_prim = is_secret_freq | is_secret_dom\n)\n\ntable(pizzas_tabule$is_secret_prim)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nFALSE  TRUE \n34781    82 \n```\n\n\n:::\n:::\n\n\nSecret primaire pour les pizzas.\n\n::: {.cell}\n\n```{.r .cell-code}\nsalades_tabule_3var <- salades_tabule_3var %>% mutate(\n  is_secret_freq = nb_obs > 0 & nb_obs < 3,\n  is_secret_dom = (tot != 0) & (max > 0.85*tot),\n  is_secret_prim = is_secret_freq | is_secret_dom\n)\n\ntable(pizzas_tabule$is_secret_prim)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nFALSE  TRUE \n34781    82 \n```\n\n\n:::\n:::\n\n\n## Création des listes de tableaux\n\nPour le cluster des pizzas.\n\n::: {.cell}\n\n```{.r .cell-code}\ntableaux_pizza <- list(\n  pizza_nuts_treff = pizzas_tabule %>% filter(naf == \"Total\") %>% select(-naf), # T1.T2\n  pizza_nuts_naf = pizzas_tabule %>% filter(treff == \"Total\") %>% select(-treff) # T3.T4.T5.T6.T7.T8\n)\n\nstr(tableaux_pizza)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 2\n $ pizza_nuts_treff:Classes 'data.table' and 'data.frame':\t516 obs. of  8 variables:\n  ..$ nuts          : chr [1:516] \"FRY2\" \"FRH0\" \"FRJ1\" \"FRC1\" ...\n  ..$ treff         : chr [1:516] \"Total\" \"Total\" \"Total\" \"Total\" ...\n  ..$ nb_obs        : num [1:516] 16041 61520 72179 61378 76172 ...\n  ..$ pizzas_tot    : num [1:516] 6.18e+09 2.33e+10 2.63e+10 2.36e+10 2.80e+10 ...\n  ..$ pizzas_max    : num [1:516] 898695 899556 899105 899731 895797 ...\n  ..$ is_secret_freq: logi [1:516] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ is_secret_dom : logi [1:516] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ is_secret_prim: logi [1:516] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..- attr(*, \".internal.selfref\")=<externalptr> \n $ pizza_nuts_naf  :Classes 'data.table' and 'data.frame':\t12120 obs. of  8 variables:\n  ..$ naf           : chr [1:12120] \"BE\" \"RU\" \"JZ\" \"MN\" ...\n  ..$ nuts          : chr [1:12120] \"Total\" \"Total\" \"Total\" \"Total\" ...\n  ..$ nb_obs        : num [1:12120] 589777 170400 106658 226737 166898 ...\n  ..$ pizzas_tot    : num [1:12120] 2.26e+11 6.65e+10 4.23e+10 8.34e+10 6.30e+10 ...\n  ..$ pizzas_max    : num [1:12120] 899556 896464 898695 899954 899982 ...\n  ..$ is_secret_freq: logi [1:12120] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ is_secret_dom : logi [1:12120] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ is_secret_prim: logi [1:12120] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..- attr(*, \".internal.selfref\")=<externalptr> \n```\n\n\n:::\n:::\n\n\n\nPour le cluster des salades.\n\n::: {.cell}\n\n```{.r .cell-code}\ntableaux_salades <- list(\n  salades_naf_treff = salades_tabule_3var %>% filter(cj == \"Total\") %>% select(-cj), # T9.T15.T21.T11.T17.T23.T13.T19.T25\n  salades_naf_cj = salades_tabule_3var %>% filter(treff == \"Total\") %>% select(-treff) # T10.T16.T22.T12.T18.T24.T14.T20.T26\n)\n\nstr(tableaux_salades)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 2\n $ salades_naf_treff: tibble [1,440 × 9] (S3: tbl_df/tbl/data.frame)\n  ..$ naf           : chr [1:1440] \"BE\" \"BE\" \"BE\" \"RU\" ...\n  ..$ treff         : chr [1:1440] \"Total\" \"Total\" \"Total\" \"Total\" ...\n  ..$ nb_obs        : num [1:1440] 589777 589777 589777 170400 170400 ...\n  ..$ crois_salades : chr [1:1440] \"salades\" \"maches\" \"batavias\" \"salades\" ...\n  ..$ tot           : num [1:1440] 5.32e+10 2.76e+10 2.56e+10 1.54e+10 8.12e+09 ...\n  ..$ max           : num [1:1440] 143880 74997 69985 142663 74949 ...\n  ..$ is_secret_freq: logi [1:1440] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ is_secret_dom : logi [1:1440] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ is_secret_prim: logi [1:1440] FALSE FALSE FALSE FALSE FALSE FALSE ...\n $ salades_naf_cj   : tibble [1,440 × 9] (S3: tbl_df/tbl/data.frame)\n  ..$ naf           : chr [1:1440] \"BE\" \"BE\" \"BE\" \"RU\" ...\n  ..$ cj            : chr [1:1440] \"Total\" \"Total\" \"Total\" \"Total\" ...\n  ..$ nb_obs        : num [1:1440] 589777 589777 589777 170400 170400 ...\n  ..$ crois_salades : chr [1:1440] \"salades\" \"maches\" \"batavias\" \"salades\" ...\n  ..$ tot           : num [1:1440] 5.32e+10 2.76e+10 2.56e+10 1.54e+10 8.12e+09 ...\n  ..$ max           : num [1:1440] 143880 74997 69985 142663 74949 ...\n  ..$ is_secret_freq: logi [1:1440] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ is_secret_dom : logi [1:1440] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ is_secret_prim: logi [1:1440] FALSE FALSE FALSE FALSE FALSE FALSE ...\n```\n\n\n:::\n:::\n\n\n## Poser le secret secondaire\n\nOn pose le secret puis on unifie les masques afin de les regrouper dans un seul dataframe.\n\nPour le cluster pizzas.\n\n::: {.cell}\n\n```{.r .cell-code}\nloc_tauargus <- \"Y:/Logiciels/TauArgus/TauArgus4.2.3/TauArgus.exe\"\noptions(rtauargus.tauargus_exe = loc_tauargus)\n\nmasques_pizza <- tab_multi_manager(\n  list_tables = tableaux_pizza,\n  list_explanatory_vars = list(\n    pizza_nuts_treff = c(\"nuts\",\"treff\"), # T1.T2\n    pizza_nuts_naf_princ = c(\"nuts\",\"naf\"), # T3.T4.T5.T6.T7.T8\n  ),\n  dir_name = \"./Exos/tauargus_files/ex_analyse_demande/\",\n  hrc = list(naf = hrc_naf_C14_To_C19, nuts = \"./Exos/hrc/nuts.hrc\"),\n  totcode = \"Total\",\n  value = \"pizzas_tot\",\n  freq = \"nb_obs\",\n  secret_var = \"is_secret_prim\"\n)\n\n# unification des masques\nmasque_pizza <- masques_pizza %>% purrr::map_dfr(\n  function(tab){\n    tab %>% \n      mutate(\n        treff = if (\"treff\" %in% names(tab)) treff else \"Total\",\n        cj = if (\"cj\" %in% names(tab)) cj else \"Total\",\n        naf = if (\"naf\" %in% names(tab)) naf else \"Total\"\n      ) %>% \n      select(\"naf\",\"treff\",\"cj\",everything()) %>%\n      rename_with(~\"is_secret_final\", last_col()) %>% \n      mutate(\n        statut_final = case_when(\n          is_secret_freq ~ \"A\",\n          is_secret_dom ~ \"B\",\n          is_secret_final ~\"D\",\n          TRUE ~ \"V\"\n        )) %>% \n      select(-matches(\"is_secret_\"))\n  }\n) %>% unique()\n\ntable(masque_pizza$statut_final)\n```\n:::\n\n\nPour le cluster salades.\n\n::: {.cell}\n\n```{.r .cell-code}\nmasques_salades <- tab_multi_manager(\n  list_tables = tableaux_salades,\n  list_explanatory_vars = list(\n    salades_naf_treff = c(\"naf\",\"treff\", \"crois_salades\"),\n    salades_naf_cj = c(\"naf\",\"cj\", \"crois_salades\")\n  ),\n  dir_name = \"./Exos/tauargus_files/ex_analyse_demande/\",\n  hrc = list(naf = hrc_naf_C14_To_C19),\n  totcode = c(naf = \"Total\", treff = \"Total\", cj = \"Total\", crois_salades = \"salades\"),\n  value = \"tot\",\n  freq = \"nb_obs\",\n  secret_var = \"is_secret_prim\"\n)\n\nmasque_salades <- masques_salades %>% purrr::map_dfr(\n  function(tab){\n    tab %>% \n      mutate(\n        treff = if (\"treff\" %in% names(tab)) treff else \"Total\",\n        cj = if (\"cj\" %in% names(tab)) cj else \"Total\",\n        naf = if (\"naf\" %in% names(tab)) naf else \"Total\"\n      ) %>% \n      select(\"naf\",\"treff\",\"cj\",everything()) %>%\n      rename_with(~\"is_secret_final\", last_col()) %>% \n      mutate(\n        statut_final = case_when(\n          is_secret_freq ~ \"A\",\n          is_secret_dom ~ \"B\",\n          is_secret_final ~\"D\",\n          TRUE ~ \"V\"\n        )) %>% \n      select(-matches(\"is_secret_\"))\n  }\n) %>% unique()\n```\n:::\n\n\n\n",
    "supporting": [
      "proteger-tableaux-suppressif_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}