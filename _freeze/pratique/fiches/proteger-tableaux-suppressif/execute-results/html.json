{
  "hash": "7622a26c6eb39d67203bfb3dedabec7b",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Protéger des tableaux avec une méthode suppressive\n---\n\nCette fiche pratique présente une façon de protéger des tableaux en utilisant une méthode suppressive grâce au package `rtauargus` qui appelle Tau-Argus depuis R. Les données utilisées peuvent être générées à partir du document [INSERER LIEN]. Le code peut être entièrement caché ou visible grâce au bouton à droite du titre. Vous pouvez aussi le faire apparaître ou disparaître au fur et à mesure de la lecture en appuyant sur les boutons Code.\n\n# Initialisation\n\nImport des packages.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nlibrary(rtauargus)\n```\n:::\n\n\nModifier le chemin ci-dessous :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nloc_tauargus <- \"C:/Users/tmm7an/Documents/SDC/TauArgus/TauArgus4.2.5/TauArgus.exe\"\noptions(rtauargus.tauargus_exe = loc_tauargus)\n```\n:::\n\n\n# Tabuler les données\n\nPour faciliter le passage des microdonnées aux données tabulées une fonction est incluse dans `rtauargus` : `tabulate_micro_data()`.\n\nLes arguments de la fonction sont les suivants :\n\n- `df`: jeu de données individuelles (data.frame ou data.table)\n- `cat_vars`: variables de croisements (catégorielles) non hiérarchiques (vecteur)\n- `hrc_vars`: variables de croisements hiérarchiques sous la forme d'une liste nommée\n- `pond_var`: variable de pondération\n- `resp_var`: indicateur(s), variable(s) de réponse\n- `marge_label`: label utilisé pour les marges (sous-totaux)\n\n## Présentation des données individuelles\n\nNous utiliserons un jeu de données entreprises (1 ligne = 1 entreprise) pour lesquelles \non dispose d'informations telles que l'activité, la catégorie juridique, \nla géographie d'implantation (variables NUTS) et la tranche d'effectifs. Pour \nchaque entreprise on dispose également du chiffre d'affaires (CA) selon le type de produits (salades, \npizzas, batavias, légumes rouges, etc.).\n\nOn importe les données et on regarde leur format.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable_legume <- readr::read_csv(\"./data/table_test.csv\", show_col_types = FALSE)\n\nstr(table_legume)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nspc_tbl_ [94,685 × 29] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n $ ident         : num [1:94685] 1 2 3 4 5 6 7 8 9 10 ...\n $ A10           : chr [1:94685] \"MN\" \"RU\" \"OQ\" \"OQ\" ...\n $ A21           : chr [1:94685] \"M\" \"R\" \"O\" \"P\" ...\n $ A38           : chr [1:94685] \"MA\" \"RZ\" \"OZ\" \"PZ\" ...\n $ a88           : num [1:94685] 70 93 84 85 86 70 43 74 37 91 ...\n $ A129          : chr [1:94685] \"M70Z\" \"R93Z\" \"O84Z\" \"P85Z\" ...\n $ a272          : num [1:94685] 702 931 841 855 862 702 433 749 370 910 ...\n $ a615          : num [1:94685] 7022 9319 8411 8559 8621 ...\n $ a732          : chr [1:94685] \"7022Z\" \"9319Z\" \"8411Z\" \"8559A\" ...\n $ type_distrib  : chr [1:94685] \"02\" \"01\" \"01\" \"01\" ...\n $ treff         : chr [1:94685] \"tr1\" \"tr1\" \"tr2\" \"tr1\" ...\n $ cj            : chr [1:94685] \"PA\" \"LL\" \"LL\" \"LL\" ...\n $ nuts0         : chr [1:94685] \"FR\" \"FR\" \"FR\" \"FR\" ...\n $ nuts1         : chr [1:94685] \"FR1\" \"FR1\" \"FR1\" \"FR1\" ...\n $ nuts2         : chr [1:94685] \"FR10\" \"FR10\" \"FR10\" \"FR10\" ...\n $ nuts3         : chr [1:94685] \"FR101\" \"FR105\" \"FR105\" \"FR105\" ...\n $ pays          : chr [1:94685] \"FR\" \"FR\" \"FR\" \"GB\" ...\n $ dep           : chr [1:94685] \"75\" \"92\" \"92\" \"92\" ...\n $ poids         : num [1:94685] 1 1 1 1 1 1 1 1 1 1 ...\n $ maches        : num [1:94685] 0 0 31.4 0 0 ...\n $ batavias      : num [1:94685] 3.8 0 2263.26 6.44 5.52 ...\n $ tomates       : num [1:94685] 0 0 9.1 0 0 0 0 0 0.5 0 ...\n $ poivrons      : num [1:94685] 0.3 0 0 0 0 0 0 0 0 0 ...\n $ radis         : num [1:94685] 60.6 53.8 18612.2 39.1 39.1 ...\n $ pizzas        : num [1:94685] 1.86 4.66 2605.06 9.03 4.51 ...\n $ naf           : logi [1:94685] NA NA NA NA NA NA ...\n $ salades       : num [1:94685] 3.8 0 2294.68 6.44 5.52 ...\n $ legumes_rouges: num [1:94685] 60.9 53.8 18621.3 39.1 39.1 ...\n $ legumes_total : num [1:94685] 64.7 53.8 20915.9 45.5 44.6 ...\n - attr(*, \"spec\")=\n  .. cols(\n  ..   ident = col_double(),\n  ..   A10 = col_character(),\n  ..   A21 = col_character(),\n  ..   A38 = col_character(),\n  ..   a88 = col_double(),\n  ..   A129 = col_character(),\n  ..   a272 = col_double(),\n  ..   a615 = col_double(),\n  ..   a732 = col_character(),\n  ..   type_distrib = col_character(),\n  ..   treff = col_character(),\n  ..   cj = col_character(),\n  ..   nuts0 = col_character(),\n  ..   nuts1 = col_character(),\n  ..   nuts2 = col_character(),\n  ..   nuts3 = col_character(),\n  ..   pays = col_character(),\n  ..   dep = col_character(),\n  ..   poids = col_double(),\n  ..   maches = col_double(),\n  ..   batavias = col_double(),\n  ..   tomates = col_double(),\n  ..   poivrons = col_double(),\n  ..   radis = col_double(),\n  ..   pizzas = col_double(),\n  ..   naf = col_logical(),\n  ..   salades = col_double(),\n  ..   legumes_rouges = col_double(),\n  ..   legumes_total = col_double()\n  .. )\n - attr(*, \"problems\")=<externalptr> \n```\n\n\n:::\n:::\n\n\n## Première utilisation : tabuler un indicateur\n\nOn veut construire le chiffre d'affaires en salades des entreprises par activité (niveau a88) et par tranche d'effectifs (treff).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsalades <- tabulate_micro_data(\n  df = table_legume,\n  cat_var = c(\"a88\", \"treff\"),\n  pond_var = \"poids\",\n  resp_var = \"salades\",\n  marge_label = \"Ensemble\"\n)\n```\n:::\n\n\nLe résultat est un tableau long avec :\n\n* Les variables de croisement (a88 et treff)\n* Différents indicateurs :\n    + `nb_obs`: comptage du nombre d'entreprises (pour appliquer la règle de fréquence)\n    + `salades_tot`: indicateur / variable de réponse (ici total du chiffre d'affaire de salades)\n    + `salades_max`: contribution maximale au chiffre d'affaires (pour appliquer la règle de dominance)\nToutes les marges (totaux et sous-totaux) ont été ajoutées à la table.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(salades)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nClasses 'data.table' and 'data.frame':\t303 obs. of  5 variables:\n $ a88        : chr  \"70\" \"93\" \"84\" \"85\" ...\n $ treff      : chr  \"Ensemble\" \"Ensemble\" \"Ensemble\" \"Ensemble\" ...\n $ nb_obs     : num  11188 2262 86 6901 19116 ...\n $ salades_tot: num  1.01e+08 1.11e+07 7.74e+05 6.14e+07 1.79e+08 ...\n $ salades_max: num  1222144 1779083 488452 3479296 12471237 ...\n - attr(*, \".internal.selfref\")=<externalptr> \n```\n\n\n:::\n:::\n\n\n## Calculer plusieurs indicateurs en même temps\n\nOn veut construire deux tableaux :  \n\n* le chiffre d'affaires de la production de pizzas des entreprises par activité (niveau A10), \npar tranche d'effectifs (treff) et catégorie juridique (cj);\n* le chiffre d'affaires de la production de tomates des entreprises par activité (niveau A10), \npar tranche d'effectifs (treff) et catégorie juridique (cj).\n\nCes deux tableaux ont les mêmes variables de croisement et deux indicateurs \ndifférents. Ils peuvent être construits en même temps.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nres_all_dtp <- tabulate_micro_data(\n  df = table_legume,\n  cat_vars = c(\"A10\", \"treff\",\"cj\"),\n  pond_var = \"poids\",\n  resp_var = c(\"pizzas\",\"tomates\"),\n  marge_label = \"Total\"\n)\n\nstr(res_all_dtp)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nClasses 'data.table' and 'data.frame':\t153 obs. of  8 variables:\n $ A10        : chr  \"MN\" \"RU\" \"OQ\" \"FZ\" ...\n $ treff      : chr  \"Total\" \"Total\" \"Total\" \"Total\" ...\n $ cj         : chr  \"Total\" \"Total\" \"Total\" \"Total\" ...\n $ nb_obs     : num  41359 25108 26686 28043 12878 ...\n $ pizzas_tot : num  2073064 353584 677739 757010 5968851 ...\n $ tomates_tot: num  93036 6941 24134 31177 56273 ...\n $ pizzas_max : num  166458 21054 240973 69855 358101 ...\n $ tomates_max: num  12099 844 7054 1463 1793 ...\n - attr(*, \".internal.selfref\")=<externalptr> \n```\n\n\n:::\n:::\n\n\n# Poser le secret primaire\n\n**Objectif** : détecter les cellules ne respectant pas les règles de confidentialité\ndans les tableaux proposés.\n\n**Consignes** : vous utiliserez les règles en vigueur à l'Insee pour la diffusion des\ntableaux issus des enquêtes entreprises.\n\n1.  Pour chacun des tableaux, vous ajouterez une variable booléenne\n    indiquant si la cellule est problématique (`TRUE`) ou non (`FALSE`),\n    au regard de chacune des règles pertinentes à appliquer:\n    \n-   Si vous appliquez la règle de fréquence, la variable créée\n    s'appellera `is_secret_freq`;\n-   Si vous appliquez la règle de dominance, la variable créée\n    s'appellera `is_secret_dom`.\n\n2.  Après avoir posé le secret, vous calculerez le nombre de cellules\n    détectées comme à risque.\n\nLe tableau `salades` est un tableau de volumes (CA), les règles de fréquence\net de dominance s'appliquent. D'après la jurisprudence Insee sur la\ndiffusion des données entreprises, le seuil de fréquence est fixé à 3 et\nle plus gros contributeur ne doit pas contribuer à plus de 85% de la\ncellule.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsalades_detect <- salades %>%\n    mutate(\n      is_secret_freq = nb_obs > 0 & nb_obs < 3,\n      is_secret_dom = (salades_tot != 0) & (salades_max > 0.85*salades_tot)\n    )\n\nsalades_detect %>% count(is_secret_freq, is_secret_dom)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   is_secret_freq is_secret_dom     n\n           <lgcl>        <lgcl> <int>\n1:          FALSE         FALSE   250\n2:          FALSE          TRUE     7\n3:           TRUE         FALSE    11\n4:           TRUE          TRUE    35\n```\n\n\n:::\n:::\n\n\n# Protéger un tableau simple\n\n**Objectif** : protéger un tableau simple en appelant Tau-Argus depuis R pour poser le secret secondaire.\n\n**Consignes** : vous utiliserez les règles en vigueur à l'Insee pour la diffusion des\ntableaux issus des enquêtes entreprises.\n\n## Poser le secret secondaire\n\nPoser un masque de secret sur un tableau comprend les étapes suivantes:\n\n1. Tout d'abord on pose le secret primaire. Pour cela, il faut créer créer des variables indicatrices :\n   1. Pour chacun des tableaux, vous ajouterez une variable booléenne indiquant si la cellule est problématique (`TRUE`) ou non (`FALSE`), au regard de chacune des règles pertinentes à appliquer :\n      - Si vous appliquez la règle de fréquence, la variable créée s'appellera `is_secret_freq`;\n      - Si vous appliquez la règle de dominance, la variable créée s'appellera `is_secret_dom`.\n   2. Puis de créer une variable qu'on appellera `is_secret_prim`, définie ainsi :\n      - `is_secret_prim = is_secret_freq` si seule la règle de fréquence doit s'appliquer;\n      - `is_secret_prim = is_secret_freq | is_secret_dom` si les deux règles doivent s'appliquer;\n2. Après avoir posé le secret primaire, vous calculerez le nombre de cellules détectées comme à risque.\n3. Ensuite, il s'agit de poser le secret secondaire en utilisant le package `rtauargus`. Les consignes d'installation de `rtauargus` et du logiciel Tau-Argus sont indiquées dans le fichier [INSERER LIEN]. Vous utiliserez notamment la fonction `tab_rtauargus()` et suivrez les étapes mentionnées pour apprendre à l'utiliser.\n4. Enfin, vous calculerez le nombre de cellules selon leur statut final. Nous utiliserons pour cela la norme européenne en notant:\n  - `A` les cellules en secret primaire à cause de la règle de fréquence\n  - `B` les cellules en secret primaire à cause de la règle de dominance (dans le futur ces cellules pourraient être notées `O`)\n  - `D` les cellules concernées par le secret secondaire\n  - `V` les cellules non touchées par le secret, cad les cellules qui pourront être diffusées.\n\nLa fonction `tab_rtauargus()` permet de poser le secret secondaire et requiert les arguments suivants :\n  - `tabular` : la table à protéger\n  - `dir_name` : le nom du répertoire où  les fichiers seront sauvegardés\n  - `files_name` : le nom utilisé pour nommer les fichiers (chaque fichier a une extension différente);\n  - `explanatory_vars` : le nom des variables de croisements présents dans la table;\n  - `secret_var` : le nom de la variable indiquant si une cellule est à risque ou non (secret primaire);\n  - `value` : nom de la variable de réponse;\n  - `freq` : nom de la variable d'effectifs;\n  - `totcode` : le code utilisé pour indiquer le total pour chacune des variables de croisements (`explanatory_vars`).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsalades_masq <- tab_rtauargus(\n  salades_detect,\n  dir_name = \"tauargus_files/exo2\",\n  files_name = \"T0\",\n  explanatory_vars = c(\"a88\",\"treff\"),\n  secret_var = \"is_secret_prim\",\n  value = \"salades_tot\",\n  freq = \"nb_obs\",\n  totcode = c(a88=\"Total\",treff=\"Total\"),\n  verbose = FALSE\n)\n```\n:::\n\n\n## Analyser les résultats\n\n### Les fichiers créés pour ou lors de l'exécution de Tau-Argus\n\nL'ensemble des fichiers créés pendant le processus se trouvent dans le répertoire\nmentionné dans l'argument `dir_name`. Tous les fichiers ont le même nom,\nmais pas la même extension:\n\n- `T0.tab` : tableau de données\n- `T0.hst` : fichier d'apriori où sont listées les cellules à risque (secret primaire)\n- `T0.rda` : fichier de métadonnées;\n- `T0.arb` : fichier batch, qui sera exécuté par Tau-Argus\n- `T0.txt` : fichier log, retraçant les étapes exécutées par Tau-Argus\n- `T0.csv` : masque au format csv\n\n### Le masque\n\nLe masque est retourné par la fonction. Ce masque est une copie de la table fournie en entrée à laquelle une variable supplémentaire, `Status`, est fournie indiquant \nle statut final de la cellule: \n\n- `B` : secret primaire (ou apriori)\n- `D` : secret secondaire\n- `V` : cellule valide, cad qui peut être diffusée\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(T0_masq)\n```\n:::\n\n\n## Bilan du secret\n\nPour faire le bilan du secret le mieux est de modifier la variable `Status` \nfournie par Tau-Argus. En effet, cette variable ne permet pas de faire la \ndistinction entre l'origine du secret primaire (fréquence ou dominance).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nT0_masq <- T0_masq %>% \n  mutate(\n    statut_final = case_when(\n      is_secret_freq ~ \"A\",\n      is_secret_dom ~ \"B\",\n      TRUE ~ Status,\n    )\n  )\n```\n:::\n\n\n\nAfin de bien appréhender l'impact du secret posé, on va non seulement compter\nle nombre de cellules masquées, mais aussi calculer la valeur des cellules masquées.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nT0_masq %>% \n  group_by(statut_final) %>% \n  summarise(\n    n_cell = n(),\n    val_cell = sum(VALUE)\n  ) %>%\n  mutate(\n    pc_n_cell = n_cell/sum(n_cell)*100,\n    pc_val_cell = val_cell/sum(val_cell)*100\n  )\n```\n:::\n\n\nOn masque 1/3 des cellules mais seulement 12% de l'information totale.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\n\nggplot(airquality, aes(Temp, Ozone)) + \n  geom_point() + \n  geom_smooth(method = \"loess\")\n```\n\n::: {.cell-output-display}\n![Temperature and ozone level.](proteger-tableaux-suppressif_files/figure-html/fig-airquality-1.png){#fig-airquality width=672}\n:::\n:::\n\n",
    "supporting": [
      "proteger-tableaux-suppressif_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}